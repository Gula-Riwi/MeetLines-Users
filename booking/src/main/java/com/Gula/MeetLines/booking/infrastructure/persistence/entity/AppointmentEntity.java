package com.Gula.MeetLines.booking.infrastructure.persistence.entity;

import com.Gula.MeetLines.booking.domain.Appointment;
import com.Gula.MeetLines.booking.domain.AppointmentStatus;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.ZonedDateTime;
import java.util.UUID;

/**
 * JPA Entity for persisting appointments to the database.
 * 
 * <p>
 * This is an <strong>Infrastructure Entity</strong>, which means:
 * </p>
 * <ul>
 * <li>It's in the INFRASTRUCTURE layer, not the domain</li>
 * <li>It has JPA annotations (@Entity, @Table, @Column)</li>
 * <li>It has NO business logic (that's in the domain Appointment)</li>
 * <li>It's a pure data structure for database mapping</li>
 * </ul>
 * 
 * <p>
 * <strong>Why separate from domain Appointment?</strong>
 * </p>
 * <ul>
 * <li><strong>Clean Architecture:</strong> Domain doesn't depend on JPA</li>
 * <li><strong>Flexibility:</strong> Can change database without touching
 * domain</li>
 * <li><strong>Testability:</strong> Domain tests don't need database</li>
 * <li><strong>Single Responsibility:</strong> This class only handles
 * persistence</li>
 * </ul>
 * 
 * <p>
 * <strong>Mapping pattern:</strong>
 * </p>
 * 
 * <pre>
 *     Domain Appointment ←→ AppointmentEntity (mapper)
 *                              ↓
 *                         Database Table
 * </pre>
 * 
 * <p>
 * <strong>Table structure matches your DDL:</strong>
 * </p>
 * 
 * <pre>
 * CREATE TABLE appointments (
 *     id SERIAL PRIMARY KEY,
 *     project_id UUID NOT NULL,
 *     app_users_id UUID NOT NULL,
 *     service_id INT NOT NULL,
 *     start_time TIMESTAMP WITH TIME ZONE NOT NULL,
 *     end_time TIMESTAMP WITH TIME ZONE NOT NULL,
 *     status VARCHAR(20) DEFAULT 'pending',
 *     price_snapshot DECIMAL(15, 2) NOT NULL,
 *     currency_snapshot VARCHAR(3) NOT NULL DEFAULT 'COP',
 *     meeting_link TEXT,
 *     user_notes TEXT,
 *     admin_notes TEXT,
 *     created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
 *     updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
 * );
 * </pre>
 * 
 * @author MeetLines Team
 * @version 1.0
 * @since 2025-12-03
 */
@Entity
@Table(name = "appointments")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class AppointmentEntity {

    /**
     * Primary key, auto-generated by database sequence.
     * Maps to: id SERIAL PRIMARY KEY
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Project/business identifier.
     * Maps to: project_id UUID NOT NULL
     */
    @Column(name = "project_id", nullable = false)
    private UUID projectId;

    /**
     * User identifier who booked the appointment.
     * Maps to: app_users_id UUID NOT NULL
     * 
     * Note: Column name is "app_users_id" to match your DDL.
     */
    @Column(name = "app_users_id", nullable = false)
    private UUID appUserId;

    /**
     * Service identifier.
     * Maps to: service_id INT NOT NULL
     */
    @Column(name = "service_id", nullable = false)
    private Integer serviceId;

    /**
     * Employee identifier who will handle this appointment.
     * Maps to: employee_id UUID NULL
     * 
     * Nullable for backward compatibility with existing appointments.
     */
    @Column(name = "employee_id", nullable = true)
    private UUID employeeId;

    /**
     * Appointment start time with timezone.
     * Maps to: start_time TIMESTAMP WITH TIME ZONE NOT NULL
     */
    @Column(name = "start_time", nullable = false)
    private ZonedDateTime startTime;

    /**
     * Appointment end time with timezone.
     * Maps to: end_time TIMESTAMP WITH TIME ZONE NOT NULL
     */
    @Column(name = "end_time", nullable = false)
    private ZonedDateTime endTime;

    /**
     * Appointment status.
     * Maps to: status VARCHAR(20) DEFAULT 'pending'
     * 
     * We use @Enumerated(STRING) to store the enum name as string.
     * Alternative: Use AttributeConverter for custom mapping.
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private AppointmentStatus status;

    /**
     * Price snapshot at booking time.
     * Maps to: price_snapshot DECIMAL(15, 2) NOT NULL
     */
    @Column(name = "price_snapshot", nullable = false, precision = 15, scale = 2)
    private BigDecimal priceSnapshot;

    /**
     * Currency code snapshot.
     * Maps to: currency_snapshot VARCHAR(3) NOT NULL DEFAULT 'COP'
     */
    @Column(name = "currency_snapshot", nullable = false, length = 3)
    private String currencySnapshot;

    /**
     * Virtual meeting link (optional).
     * Maps to: meeting_link TEXT
     */
    @Column(name = "meeting_link", columnDefinition = "TEXT")
    private String meetingLink;

    /**
     * User notes about the appointment (optional).
     * Maps to: user_notes TEXT
     */
    @Column(name = "user_notes", columnDefinition = "TEXT")
    private String userNotes;

    /**
     * Admin notes (optional, not visible to user).
     * Maps to: admin_notes TEXT
     */
    @Column(name = "admin_notes", columnDefinition = "TEXT")
    private String adminNotes;

    /**
     * Record creation timestamp.
     * Maps to: created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
     * 
     * @PrePersist ensures this is set automatically on insert.
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private ZonedDateTime createdAt;

    /**
     * Last update timestamp.
     * Maps to: updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
     * 
     * @PreUpdate ensures this is updated automatically on every update.
     */
    @Column(name = "updated_at", nullable = false)
    private ZonedDateTime updatedAt;

    /**
     * JPA lifecycle callback: sets createdAt and updatedAt before insert.
     * 
     * This is called automatically by JPA before persisting a new entity.
     */
    @PrePersist
    protected void onCreate() {
        ZonedDateTime now = ZonedDateTime.now();
        this.createdAt = now;
        this.updatedAt = now;
    }

    /**
     * JPA lifecycle callback: updates updatedAt before update.
     * 
     * This is called automatically by JPA before updating an existing entity.
     */
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = ZonedDateTime.now();
    }

    /**
     * Converts this JPA entity to a domain Appointment.
     * 
     * <p>
     * This is the <strong>toDomain()</strong> mapping method.
     * </p>
     * 
     * <p>
     * <strong>Why this direction?</strong>
     * </p>
     * <p>
     * Infrastructure knows about domain, but domain doesn't know about
     * infrastructure.
     * So the conversion logic lives here, not in the domain Appointment class.
     * </p>
     * 
     * @return Domain Appointment object
     */
    public Appointment toDomain() {
        return new Appointment(
                this.id,
                this.projectId,
                this.appUserId,
                this.serviceId,
                this.employeeId,
                this.startTime,
                this.endTime,
                this.status,
                this.priceSnapshot,
                this.currencySnapshot,
                this.meetingLink,
                this.userNotes,
                this.adminNotes,
                this.createdAt,
                this.updatedAt);
    }

    /**
     * Creates a JPA entity from a domain Appointment.
     * 
     * <p>
     * This is the <strong>fromDomain()</strong> mapping method.
     * </p>
     * 
     * <p>
     * <strong>Use cases:</strong>
     * </p>
     * <ul>
     * <li>Saving a new appointment (id will be null)</li>
     * <li>Updating an existing appointment (id will be set)</li>
     * </ul>
     * 
     * @param appointment Domain Appointment object
     * @return JPA AppointmentEntity
     */
    public static AppointmentEntity fromDomain(Appointment appointment) {
        AppointmentEntity entity = new AppointmentEntity();
        entity.setId(appointment.getId());
        entity.setProjectId(appointment.getProjectId());
        entity.setAppUserId(appointment.getAppUserId());
        entity.setServiceId(appointment.getServiceId());
        entity.setEmployeeId(appointment.getEmployeeId());
        entity.setStartTime(appointment.getStartTime());
        entity.setEndTime(appointment.getEndTime());
        entity.setStatus(appointment.getStatus());
        entity.setPriceSnapshot(appointment.getPriceSnapshot());
        entity.setCurrencySnapshot(appointment.getCurrencySnapshot());
        entity.setMeetingLink(appointment.getMeetingLink());
        entity.setUserNotes(appointment.getUserNotes());
        entity.setAdminNotes(appointment.getAdminNotes());
        entity.setCreatedAt(appointment.getCreatedAt());
        entity.setUpdatedAt(appointment.getUpdatedAt());
        return entity;
    }
}
